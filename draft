Leasing process
---------------
- LeaseCoordinator
  - update table on 'wake up'
  - spawn LeaseRenewer and LeaseTaker and connect them together
  - expose 'GetLeases' method


Implemetation
-------------
- LeaseCoordinator
  - GetLeases()
    - call LeaseRenewer/Holder.GetLeases()

- LeaseRenewer
loop forever or maybe the coordinator should call us?
   if leases list is empty
     return
   newLeases <- manager.Scan()
   for each lease in newleases
     if we have this LEASE_KEY AND newOwnerIdentifier != oldOwnerIdentifier
       we lost this counter. release. delete from old leases and update leases table
     else
       increment counter in 1 and update in db
    sleep 1~2 minute
   for each lease in newLeases - oldLeases
     test if it's state(counter) doesn't change if this scan
       increment expiryCounter in 1
       if it's expired (counter >= 5)
         update it's leaseOwner to null

- LeaseTaker
loop forever
  <-get timer(between 1-55 give after 1~2 minute, and between 56-00 give it after 1hour-(now().minutes() + 1))
  all_leases <- scan all leases table
  num_lease_should_have <- all_leases_length / number_of_workers + (numLeases % numWorkers == 0 ? 0 : 1) // if numWorkers doesn't evenly divide numLeases
  num_leases_to_take <- num_lease_should_have - my_count
  expired_leases <- get expired leases
  shuffle(expired leases) // coordinator don't all try to contend for the same leases.
  if expired_leases > 0
    take all leases
  else // we steal
    // see: https://github.com/awslabs/amazon-kinesis-client/blob/master/src/main/java/com/amazonaws/services/kinesis/leases/impl/LeaseTaker.java#L436
    leases_to_steal <- choose_lease_to_steal()
      for each lease in lease_to_steal
        take them and and add to renewer

Procedures
----------
1. UPDATE_TABLE:
   - scan A = 'ironbeast' and B = 'leases_table'
   - create stateless item contains(key, nil, ..., nil) for each A - B
     - table schema: ['leaseKey', 'leaseOwner', 'leaseCounter']

